"use strict";

exports.__esModule = true;
exports.onError = exports.fetchList = exports.useList = undefined;

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _get = require("lodash/get");

var _get2 = _interopRequireDefault(_get);

var _react = require("react");

var _reactRedux = require("react-redux");

var _customFunctions = require("../../utils/customFunctions");

var _utils = require("../../utils");

var _redux = require("./redux");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/**
 * On Error
 *
 * @param {Object} params
 * @param {Object} params.err
 * @param {Function} params.dispatch
 * @param {Object} params.customFunctions
 */
var onError = function onError(_ref) {
    var err = _ref.err,
        dispatch = _ref.dispatch,
        customFunctions = _ref.customFunctions;

    var step = "LIST";
    var network = "";
    var errorProps = {
        err: err,
        step: step,
        network: network,
        updateState: function updateState() {
            dispatch((0, _redux.setListError)(err));
            dispatch((0, _redux.setListLoading)(false));
        },
        dispatch: dispatch,
        customFunctions: customFunctions
    };
    (0, _utils.handleError)(errorProps);
};
/**
 * Handle Fetch List when response is ok
 *
 * @param {Object} params
 * @param {Object} params.result
 * @param {Object} params.dispatch
 * @param {Object} params.customFunctions
 */
var fetchListOk = function fetchListOk(_ref2) {
    var result = _ref2.result,
        dispatch = _ref2.dispatch,
        customFunctions = _ref2.customFunctions;
    var data = result.data;

    var networksArray = (0, _get2.default)(data, ["networks", "applicable"], false);
    if (networksArray && networksArray.length) {
        dispatch((0, _redux.storeList)(networksArray));
        dispatch((0, _redux.setListLoading)(false));
    } else {
        var err = {
            message: "Server response does not contain proper network data"
        };
        onError({ err: err, dispatch: dispatch, customFunctions: customFunctions });
    }
};
/**
 * Fetch List
 *
 * @param {Object} params
 * @param {Object} params.dispatch
 * @param {Object} params.customFunctions
 * @param {String} params.baseURL
 * @param {String} params.clientId
 * @param {String} params.country
 */
var fetchList = function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee(_ref4) {
        var dispatch = _ref4.dispatch,
            customFunctions = _ref4.customFunctions,
            baseURL = _ref4.baseURL,
            clientId = _ref4.clientId,
            country = _ref4.country;

        var result, err, _err;

        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        dispatch((0, _redux.setListLoading)(true));
                        _context.prev = 1;
                        _context.next = 4;
                        return (0, _customFunctions.getExpressList)({ params: { url: baseURL, clientId: clientId, country: country } }, customFunctions);

                    case 4:
                        result = _context.sent;

                        if (result.response.ok) {
                            fetchListOk({ result: result, dispatch: dispatch, customFunctions: customFunctions });
                        } else {
                            err = result.err;

                            onError({ err: err, dispatch: dispatch, customFunctions: customFunctions });
                        }
                        _context.next = 12;
                        break;

                    case 8:
                        _context.prev = 8;
                        _context.t0 = _context["catch"](1);
                        _err = { message: _context.t0.message };

                        onError({ err: _err, dispatch: dispatch, customFunctions: customFunctions });

                    case 12:
                    case "end":
                        return _context.stop();
                }
            }
        }, _callee, undefined, [[1, 8]]);
    }));

    return function fetchList(_x) {
        return _ref3.apply(this, arguments);
    };
}();
/**
 * Custom hook that run list async and store list response
 * @param {Object} customFunctions
 */
var useList = function useList(customFunctions) {
    var dispatch = (0, _reactRedux.useDispatch)();
    var baseURL = (0, _reactRedux.useSelector)(function (state) {
        return state.configuration.baseURL;
    });
    var clientId = (0, _reactRedux.useSelector)(function (state) {
        return state.configuration.clientId;
    });
    var country = (0, _reactRedux.useSelector)(function (state) {
        return state.configuration.country;
    });
    (0, _react.useEffect)(function () {
        if (baseURL && clientId && country) {
            fetchList({ dispatch: dispatch, customFunctions: customFunctions, baseURL: baseURL, clientId: clientId, country: country });
        }
    }, [baseURL, clientId, country]);
};

exports.useList = useList;
exports.fetchList = fetchList;
exports.onError = onError;
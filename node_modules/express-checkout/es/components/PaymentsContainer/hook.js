import _regeneratorRuntime from "babel-runtime/regenerator";

var _this = this;

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

import get from "lodash/get";
import { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { getExpressList } from "../../utils/customFunctions";
import { handleError } from "../../utils";
import { setListLoading, setListError, storeList } from "./redux";

/**
 * On Error
 *
 * @param {Object} params
 * @param {Object} params.err
 * @param {Function} params.dispatch
 * @param {Object} params.customFunctions
 */
var onError = function onError(_ref) {
    var err = _ref.err,
        dispatch = _ref.dispatch,
        customFunctions = _ref.customFunctions;

    var step = "LIST";
    var network = "";
    var errorProps = {
        err: err,
        step: step,
        network: network,
        updateState: function updateState() {
            dispatch(setListError(err));
            dispatch(setListLoading(false));
        },
        dispatch: dispatch,
        customFunctions: customFunctions
    };
    handleError(errorProps);
};
/**
 * Handle Fetch List when response is ok
 *
 * @param {Object} params
 * @param {Object} params.result
 * @param {Object} params.dispatch
 * @param {Object} params.customFunctions
 */
var fetchListOk = function fetchListOk(_ref2) {
    var result = _ref2.result,
        dispatch = _ref2.dispatch,
        customFunctions = _ref2.customFunctions;
    var data = result.data;

    var networksArray = get(data, ["networks", "applicable"], false);
    if (networksArray && networksArray.length) {
        dispatch(storeList(networksArray));
        dispatch(setListLoading(false));
    } else {
        var err = {
            message: "Server response does not contain proper network data"
        };
        onError({ err: err, dispatch: dispatch, customFunctions: customFunctions });
    }
};
/**
 * Fetch List
 *
 * @param {Object} params
 * @param {Object} params.dispatch
 * @param {Object} params.customFunctions
 * @param {String} params.baseURL
 * @param {String} params.clientId
 * @param {String} params.country
 */
var fetchList = function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref4) {
        var dispatch = _ref4.dispatch,
            customFunctions = _ref4.customFunctions,
            baseURL = _ref4.baseURL,
            clientId = _ref4.clientId,
            country = _ref4.country;

        var result, err, _err;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        dispatch(setListLoading(true));
                        _context.prev = 1;
                        _context.next = 4;
                        return getExpressList({ params: { url: baseURL, clientId: clientId, country: country } }, customFunctions);

                    case 4:
                        result = _context.sent;

                        if (result.response.ok) {
                            fetchListOk({ result: result, dispatch: dispatch, customFunctions: customFunctions });
                        } else {
                            err = result.err;

                            onError({ err: err, dispatch: dispatch, customFunctions: customFunctions });
                        }
                        _context.next = 12;
                        break;

                    case 8:
                        _context.prev = 8;
                        _context.t0 = _context["catch"](1);
                        _err = { message: _context.t0.message };

                        onError({ err: _err, dispatch: dispatch, customFunctions: customFunctions });

                    case 12:
                    case "end":
                        return _context.stop();
                }
            }
        }, _callee, _this, [[1, 8]]);
    }));

    return function fetchList(_x) {
        return _ref3.apply(this, arguments);
    };
}();
/**
 * Custom hook that run list async and store list response
 * @param {Object} customFunctions
 */
var useList = function useList(customFunctions) {
    var dispatch = useDispatch();
    var baseURL = useSelector(function (state) {
        return state.configuration.baseURL;
    });
    var clientId = useSelector(function (state) {
        return state.configuration.clientId;
    });
    var country = useSelector(function (state) {
        return state.configuration.country;
    });
    useEffect(function () {
        if (baseURL && clientId && country) {
            fetchList({ dispatch: dispatch, customFunctions: customFunctions, baseURL: baseURL, clientId: clientId, country: country });
        }
    }, [baseURL, clientId, country]);
};

export { useList, fetchList, onError };